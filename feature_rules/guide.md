# 功能开发实践指南

## 1. 引言与目的

AI 辅助编程工具已成为提升新功能开发效率与质量的关键驱动力。本文档旨在为团队提供一份实战指南，聚焦在新功能开发全流程中，如何运用 Cursor、VS Code 插件等 AI 工具，并结合业界先进理念，提供可落地的策略和技巧。目标是帮助团队成员更智能地工作，将精力聚焦于架构设计、复杂逻辑攻坚和用户体验创新。

**核心原则：AI 是智能的“副驾驶”，开发者是最终的“机长”。专业判断、代码审查和对底层机制的深刻理解是不可替代的。**

## 2. AI 在新功能开发各阶段的实战应用 (C++/Qt Linux 桌面)

### 2.1 需求理解与技术预研阶段

*   **AI 应用技巧：**
    *   **深度需求挖掘：** 将 PRD（产品需求文档）或功能点描述喂给 AI，要求其不仅提炼技术点，还要 **追问潜在的边界条件、用户场景和可能的交互冲突**。
        *   *Prompt 示例 :* "分析以下‘文件批量重命名（支持正则表达式、预览、撤销）’功能需求。基于 Qt，列出核心技术挑战，并**提出 3 个容易被忽略的边缘用户场景**及其应对思路。"
    *   **方案多角度对比：** 针对特定技术点，如要求 AI 提供 **至少两种不同的 Qt 实现思路或 C++库选项，并分析其在性能、内存占用、开发复杂度、社区支持度等方面的差异**。
        *   *Prompt 示例 :* "为 Qt 应用实现一个高性能的自定义日志记录模块，需支持异步写入、日志级别控制、滚动文件。请对比使用 `QDebug` 重定向+自定义消息处理器 vs. 第三方 C++日志库（如 spdlog、easylogging++）的优劣，并给出选择建议。"
    *   **系统调用与底层 API 精确查询：** 明确告知 AI 目标 Linux 内核版本或特定库版本，以获取更精准的 API 用法和示例。
        *   *Prompt 示例:* "在 Linux（Kernel 5.4+）C++中，如何使用 `io_uring` 实现高效的异步文件读取？请提供一个最小化的 C++示例，并解释关键结构体和函数调用流程。"

### 2.2 架构设计与模块划分

*   **AI 应用技巧：**
    *   **基于模式的架构建议：** 描述功能模块的职责和交互关系后，可以询问 AI **“基于此需求，有哪些常见的设计模式（如 MVVM, MVC, Event Bus, Service Locator for Qt）可以应用？请阐述其在 C++/Qt 中的具体落地方式及利弊。”**
    *   **接口契约初拟与迭代：** 让 AI 生成模块间 C++头文件接口初稿，然后**通过追问来完善接口的 const 正确性、异常安全性保证、参数校验逻辑、以及 Qt 信号槽的粒度设计。**
        *   *Prompt 示例 (迭代):*
            1.  "为‘标签管理’模块和‘文件视图’模块设计 C++接口，标签数据变更时，文件视图需要更新。"
            2.  AI 给出初稿后："请优化 `TagManager` 的 `getTagsForFile(const QString& filePath)` 接口，考虑文件不存在的情况如何返回？返回 `QList<Tag*>` 还是 `QList<QString>` 更合适？如果标签对象由 `TagManager` 管理生命周期，这里应该返回指针还是值？"
    *   **依赖关系可视化辅助：**  可以要求 AI 列出模块间的核心依赖关系和数据流向，辅助开发者手动绘制架构图或使用工具分析。一个好用的技巧是让 AI 直接生成 planutUML 图的代码。
### 2.3 编码实现：AI 加速与质量提升

*   **核心实践模式：上下文隔离的 Demo 驱动开发 (强化)**
    *   **理念：** AI 在小而美的上下文中最能发挥威力。复杂功能先在隔离的 C++/Qt Demo 中借助 AI 快速原型和验证核心逻辑，再整合。
    *   **技巧：**
        *   **精确描述 Demo 环境：** "创建一个基于 Qt 6.8 Widgets 的 CMake 项目 Demo，目标是实现一个支持多选和拖拽排序的 `QListWidget`，并将排序结果通过信号发射出去。"
        *   **利用 AI 进行“脚手架”搭建：** 从 `.pro` / `CMakeLists.txt` 文件、基础 `main.cpp`、核心 QWidget 类骨架开始，逐步让AI填充。
        *   **在 Demo 中与 AI“结对编程”：** 如使用 Cursor 的“Edit in Place”或 VS Code Copilot 的行内建议，针对具体代码行或小函数块进行迭代修改和优化。

*   **其他编码技巧：**
    *   **现代 C++与 Qt 最佳实践引导：** "将这段使用 `QVector<QObject*>` 并手动 `delete` 的代码，改写为使用智能指针（如 `QScopedPointer` 或 `std::unique_ptr` 配合 `QObject` 父子关系）管理，确保异常安全和无内存泄漏。"
    *   **Qt 特有机制辅助：** "我需要在后台线程处理数据，完成后更新 UI。请展示如何使用 `QtConcurrent::run` 配合信号槽机制安全地实现这一过程，并解释线程亲和性问题。"
    *   **算法/逻辑片段的“多解生成与择优”：** 针对一个具体算法（如特定规则的字符串匹配、数据结构转换），可以要求 AI 提供多种实现方式，然后开发者基于可读性、性能、C++标准库依赖等因素进行选择。
    *   **错误处理与资源管理：** "分析这段 C++代码，指出潜在的资源泄漏风险（文件句柄、网络连接、Qt 对象），并给出使用 RAII 或 Qt 特定机制的改进建议。"

### 2.4 测试与调试

*   **AI 应用技巧：**
    *   **基于代码行为的 QTest 用例生成：** 选中一个函数或类，要求 AI "为这个 C++函数生成 QTest 单元测试，重点覆盖其所有逻辑分支、边界条件（空输入、最大值、非法值）和异常抛出情况。请包含必要的 `QCOMPARE` 和 `QVERIFY` 断言。"
    *   **复杂场景的 Mock 数据与行为定义：** "为测试 `FileProcessor` 类（依赖 `NetworkService` 和 `DatabaseManager`），请使用 GMock 为这两个依赖生成 Mock 类，并展示如何在测试用例中设置 `NetworkService::fetchData()` 返回特定数据或抛出异常。"
    *   **调试线索的深度分析：** 将 GDB 的详细输出（包括调用栈、变量值、内存地址）提供给 AI，并询问 "基于以下 GDB 输出，分析程序崩溃的可能原因。重点关注指针问题、内存越界、Qt 对象生命周期或线程安全问题。请给出至少 3 个排查方向和对应的 GDB 调试命令建议。"

### 2.5 文档与维护

*   **AI 应用技巧：**
    *   **“自文档化”代码辅助：** 要求 AI 生成的代码包含清晰的 Doxygen 注释，解释复杂逻辑、参数含义和返回值。
    *   **代码变更影响分析（初步）：** "我修改了 `CoreDataModel` 类的这个核心数据结构，请分析可能对项目中哪些其他模块（如 `DataView`、`ReportGenerator`）产生影响，并列出需要重点回归测试的功能点。" (AI 目前可能无法完美做到，但可以提供初步线索)

## 3. AI 协作的核心理念与高级技巧

### 3.1 思维转变：从“命令下达”到“协同探索”

*   **理念：** 将 AI 视为一个初级但知识广博的结对编程伙伴，而非简单的代码生成器。你需要引导、启发、质疑和修正它。
*   **技巧：** 使用开放式问题、引导式对话，鼓励 AI 提供多种方案。例如，不要只说“写一个排序函数”，而是“我需要一个对 `QList<CustomObject*>` 排序的函数，按对象的某个成员变量（日期类型）降序排列，同时考虑性能和稳定性，有哪些 C++标准库或 Qt 提供的方法可以高效实现？请比较一下。”

### 3.2 Prompt 工程：新时代的“需求分析”与“精确制导”

*   **理念：** Prompt 的质量直接决定 AI 输出的质量。撰写 Prompt 本身就是一种技术活，需要像对待软件需求分析一样严谨。
*   **技巧：**
    *   **角色扮演 (Role Prompting)：** "假设你是一位有 10 年经验的 Qt 资深开发者，请审查以下 C++代码..."
    *   **提供示例 (Few-shot Prompting)：** "我希望将这种格式的输入字符串 `'key1=value1;key2=value2'` 转换为 `QMap<QString, QString>`。例如，输入 `'name=John;age=30'` 应输出一个包含 `{"name", "John"}` 和 `{"age", "30"}` 的 QMap。请为我编写这个转换函数。"
    *   **明确约束与期望：** 指定 C++标准、Qt 版本、代码风格、性能要求、错误处理方式等。

### 3.3 上下文构建策略：聚焦与隔离

*   **理念：** AI 对上下文长度和复杂度敏感。通过精简和聚焦上下文，可以获得更准确、更相关的输出。
*   **技巧：**
    *   **Demo 驱动开发 (再强调)：** 这是最重要的上下文隔离策略。
    *   **代码块选中：** 在 Cursor 或 VS Code 中，精确选中你希望 AI 处理的代码片段。
    *   **“上下文窗口”意识：** 对于大型文件或复杂逻辑，将问题分解，分段与 AI 交互，而不是一次性抛给它整个文件。

### 3.4 迭代与反馈循环：与 AI 共同进化

*   **理念：** 不要期望一次完美。AI 编程是一个反复试验、获取反馈、调整 Prompt、再次尝试的过程。
*   **技巧：**
    *   **追问与细化：** "你生成的这个方案没有考虑到线程安全问题，请修改。" 或 "这个代码片段的时间复杂度是多少？有没有更优化的方法？"
    *   **错误驱动学习：** 当 AI 给出错误或不满意的答案时，分析原因，尝试不同的提问方式或补充更多上下文。

### 3.5 多角度验证与批判性采纳

*   **理念：** 即使是顶级模型也可能产生“幻觉”或不完全正确的代码。交叉验证和人类的批判性思维是最后一道防线。
*   **技巧：**
    *   **“主题阅读”式提问：** 针对关键问题，可以尝试用不同措辞向同一个 AI 工具提问，或者使用不同的 AI 工具（如果团队有多种选择）获取不同答案，对比分析。
    *   **代码审查标准不降低：** 所有 AI 生成的代码都必须经过和手写代码同样严格的 Code Review 流程。

### 3.6 利用 AI 进行“元认知”：让 AI 解释其思路

*   **理念：** 要求 AI 解释其生成的代码或设计决策，不仅能帮助你理解，也能暴露其潜在的逻辑缺陷。
*   **技巧：** "请解释你为什么选择使用 `std::async` 而不是 `QtConcurrent::run` 来实现这个后台任务？" 或 "你生成的这段 C++代码的核心逻辑是什么？每一步的作用是什么？"

### 3.7 持续学习与适应 AI 的进化

*   **理念：** AI 技术和工具在快速发展。保持学习心态，关注新模型、新特性和新的 Prompt 工程技巧。
*   **技巧：** 定期关注 AI 工具的更新日志，参与社区讨论，尝试新的用法。

## 4. AI 辅助编程的 PDTAC 实践框架 (依据 Plan, Do, Test, Action, Commit)

PDTAC 模型提供了一个结构化的工作流程，帮助我们更系统、更有效地将 AI 融入到新功能开发的各个环节，特别是当 AI 扮演更主动角色（甚至“AI 自编码”）时。下面我们根据**Plan (规划)、Do (执行)、Test (测试)、Action (行动/调整)、Commit (提交/确认)** 的含义，结合 C++/Qt 开发实践进行阐述。

### 4.1 P - Plan (规划与设计)

*   **核心意义：** 在动手编码之前，进行周密的规划、需求分析和高层设计。明确“做什么”、“为什么做”、“如何衡量成功”，并为 AI 的介入设定清晰的边界和目标。**这不仅仅是定义问题，更是制定一个可执行的蓝图。**
*   **C++/Qt 实践：**
    *   **需求深度分析与目标设定：**
        *   不仅仅是“我要一个播放列表”，而是“我们需要一个支持百万级项目的、可异步加载、支持拖拽排序和多种元数据展示的 Qt 播放列表模块，性能目标是[具体指标]，最终需要无缝集成到现有[应用名]的[某视图]中。”
        *   定义清晰的用户故事和验收标准，这些将成为后续 Test 阶段的依据。
    *   **架构选型与接口预定义：**
        *   决定核心技术栈（如 Qt 版本、C++标准、是否引入特定第三方库如 Lucene++）。
        *   初步设计模块间的核心接口（如 `AbstractSearchEngine` 的 API），明确数据契约（如 `SearchResult` 对象的结构）。**此时可以借助 AI 进行初步的接口草案生成和技术选型讨论。**
        *   规划错误处理策略（如使用 `std::error_code`，Qt 信号传递错误信息）。
    *   **任务分解与 AI 分工：**
        *   将大功能分解为更小的、可管理的开发单元（如数据库交互层、UI 展现层、核心逻辑控制层）。
        *   **明确哪些部分可以高度依赖 AI 生成，哪些部分需要人工主导，哪些部分需要 AI 辅助优化。** 例如，UI 骨架和简单数据类可以交给 AI，核心算法和复杂状态管理可能需要人工设计，AI 辅助实现。
    *   **制定迭代计划：** 对于复杂功能，规划分阶段的开发和交付，每个阶段都有明确的 AI 辅助目标。

### 4.2 D - Do (执行与实现)

*   **核心意义：** 根据 Plan 阶段制定的蓝图，开始具体的编码和实现工作。**AI 在此阶段扮演核心的“代码生成者”或“智能助手”角色，开发者则负责引导、监督和整合 AI 的产出。**
*   **C++/Qt 实践：**
    *   **AI 驱动的 Demo 原型验证：**
        *   针对规划中的关键模块或复杂交互，首先利用 AI 快速搭建独立的 C++/Qt Demo 进行技术验证。例如，先让 AI 生成一个带 `QListView` 和自定义 Model 的基础 UI 框架，再逐步集成搜索逻辑。
    *   **结构化的 Prompt 指令：**
        *   基于 Plan 阶段的接口定义和模块职责，向 AI 发出精确的编码指令。例如：“请为 `PlaylistDBManager` 类实现一个 `loadSongsFromPath(const QString& path)` 方法，该方法应异步从指定路径下的 SQLite 数据库加载歌曲信息，并通过 Qt 信号 `songsLoaded(QList<SongData>)` 返回结果。请注意错误处理和线程安全。”
    *   **AI 与人工协同编码：**
        *   对于 AI 生成的代码，开发者进行审查、修改和完善。
        *   开发者编写核心或复杂部分，AI 辅助完成样板代码、工具函数或特定算法的实现。
        *   **利用 IDE（Cursor, VS Code）的 AI 集成特性进行实时代码补全、片段生成和即时重构。**
    *   **遵循编码规范与设计原则：** 在与 AI 交互时，持续强调遵循团队的 C++/Qt 编码规范（如命名、格式）和 SOLID 等设计原则。

### 4.3 T - Test (测试与验证)

*   **核心意义：** 对“Do”阶段的产出进行系统性的测试，确保其满足 Plan 阶段定义的功能需求、性能指标和质量标准。**AI 不仅是代码的生产者，也可以是测试的辅助者。**
*   **C++/Qt 实践：**
    *   **单元测试 (QTest)：**
        *   要求 AI 为生成的 C++/Qt 类和方法生成 QTest 单元测试用例，覆盖各种输入、边界条件和异常情况。
        *   开发者审查并补充 AI 生成的测试用例，确保测试覆盖率。
    *   **集成测试：**
        *   设计测试场景，验证不同模块（可能部分由 AI 生成，部分人工编写）协同工作的正确性。
        *   例如，测试播放列表模块与音乐播放引擎模块的数据交互是否符合预期。
    *   **UI 自动化测试 (Squish, Qt Test)：**
        *   对于包含 UI 的功能，如果条件允许，可以探索 AI 辅助生成 UI 测试脚本的潜力。
    *   **性能测试与基准测试：**
        *   针对 Plan 中定义的性能指标（如加载百万级项目的时间），设计并执行性能测试。
        *   利用 AI 分析性能瓶颈，并辅助生成优化方案。
    *   **代码静态分析与审查：**
        *   使用 Cppcheck, Clang-Tidy 等工具对 AI 生成的代码进行静态分析。
        *   人工进行严格的代码审查，关注 C++/Qt 特有的问题（内存管理、对象生命周期、线程安全、信号槽连接等）。

### 4.4 A - Action (行动/调整与优化)

*   **核心意义：** 根据 Test 阶段的反馈和发现的问题，采取具体的行动进行修复、调整和优化。**这是一个持续改进的循环，AI 可以在问题定位、方案生成和代码修改方面提供支持。**
*   **C++/Qt 实践：**
    *   **Bug 修复：**
        *   将测试中发现的 Bug（包括 AI 生成代码中的 Bug）反馈给 AI，要求其分析原因并提供修复方案，或直接生成修复后的代码。
        *   例如：“AI，之前的 `loadSongsFromPath` 方法在路径包含特殊字符时会崩溃，请修复这个问题。”
    *   **性能优化：**
        *   基于性能测试结果，与 AI 共同分析瓶颈所在（如不必要的拷贝、低效的循环、UI 渲染问题）。
        *   要求 AI 针对性地优化代码，例如：“请优化这个 Qt Model 的数据获取逻辑，减少对底层数据的重复查询。” 或 “这个自定义 `QStyledItemDelegate` 的 `paint` 方法效率较低，请给出优化建议。”
    *   **设计重构：**
        *   如果测试暴露出设计层面的问题（如高耦合、低内聚），可能需要回到 Plan 或 Do 阶段进行调整。AI 可以辅助进行代码重构，以符合更好的设计原则。
        *   例如：“当前 `SearchEngine` 类职责过多，请根据单一职责原则将其拆分为 `QueryParser`、`IndexAccessor` 和 `ResultFormatter` 等更小的类。”
    *   **用户体验调整：**
        *   根据 UI 测试或用户反馈，调整 UI 交互逻辑、布局或视觉表现。AI 可以辅助快速生成不同 UI 方案的原型。

### 4.5 C - Commit (提交/确认与整合)

*   **核心意义：** 当经过充分的 Test 和 Action（调整优化）后，确认当前阶段的产出达到质量标准，可以将其“提交”并整合到更大的系统中，或者作为阶段性成果进行归档。**这代表一个开发迭代周期的完成，并为下一个周期做好准备。**
*   **C++/Qt 实践：**
    *   **代码版本控制：**
        *   将经过测试和审查的、由 AI 辅助生成的（或人工编写的）稳定代码提交到版本控制系统（如 Git）。编写清晰的 Commit Message。
    *   **文档更新：**
        *   更新相关的设计文档、API 文档（如 Doxygen 注释）、用户手册等，确保文档与代码同步。AI 可以辅助生成或更新这些文档。
    *   **模块集成：**
        *   将开发完成的功能模块小心地集成到主应用程序中，并进行回归测试，确保集成过程没有引入新的问题。
    *   **知识沉淀与复盘：**
        *   总结在本次 PDTAC 循环中 AI 辅助开发的经验教训，哪些做得好，哪些可以改进。将有效的 Prompt 模式、AI 协作技巧记录下来，供团队共享。
        *   **评估 AI 在本次迭代中的贡献和局限性，为后续更好地利用 AI 积累经验。**

通过将 PDTAC（Plan, Do, Test, Action, Commit）模型应用于 AI 辅助的 C++/Qt 新功能开发，我们可以建立一个更规范、更高效、更可控的研发流程，充分发挥 AI 的潜力，同时保障软件的最终质量。

## 5. 结论：拥抱协作，持续进化

AI 辅助编程为功能开发带来了范式转变。它不是取代开发者，而是赋予我们更强大的能力，让我们从繁琐的细节中解放出来，更专注于创造性的挑战。成功应用 AI 的关键在于掌握正确的理念、技巧和协作框架（如 PDTAC），并将其融入我们日常的开发流程中。

这份指南是一个起点。我们鼓励团队成员在实践中不断探索、总结经验，并积极分享，共同推动团队在 AI 辅助开发领域的能力进化。